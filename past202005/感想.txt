A問題はs=tとs.upper=t.upper
B問題は最終的に各問題を解いた人数を求めてから計算
C問題は愚直に計算、10^9を超えたら打ち切り
D問題は最低限のif文でゴリ押しした
例えば0,0が.になるのは1しかない
E問題は愚直にシミュレート
F問題は1行目とN行目に同じ文字が含まれるかを調べて
それを順に行い存在しなければ-1
あればそのまま出力
G問題はDFSで最短経路を求めた
-200〜200と勘違いして1WA
201マス目を使って回り道できることを失念していた
H問題はDP、最初に状態を持たずにジャンプ中着地して
サンプルが通らなかったけれども
行動が終わっている/終わっていないの状態を持たせた

ここまでは制約が小さいのでほとんど工夫は必要なかった

I問題は愚直にやると間に合わないので
「どの行/列が入れ替わっているか」と
「今、転置しているかしていないか」だけを
状態として持ってシミュレートした
1WAして最初理由が分からなかったけれど
単にintでオーバーフローしているだけだった

J問題は「最後に食べた寿司の美味しさ」、
言い換えると「食べた寿司の中で一番大きい美味しさ」が
並んでいる子どもに対して単調減少するので
どの子どもが食べるかは二分探索で求められる
O(M log N)は制約に対して十分小さいので
毎回二分探索しても問題ない

K問題は「各机に乗っている一番上のコンテナ」
「各机に接しているコンテナ」
「各コンテナのすぐ下のコンテナ」
「各コンテナのすぐ上のコンテナ」の
4つの状態だけを管理してシミュレートした
この4つはクエリをO(1)で処理できる
最終的にどの机に存在するかは
各机から一個ずつ上に見ていけば求められて
なおかつこの計算量はコンテナの数で抑えられて
クエリ処理O(Q)+後処理O(N)で
制約に対して十分小さいので問題ない

L問題はaが1or2であることに気付かなくて一回読み飛ばした
aが小さいので一番前にある商品と2番目にある商品の最大値が高速に求められれば良いので
優先順位付きキューを2つ持って管理した
また商品を選んだときにその棚を全部一個前にずらす必要があるので
各商品からどの棚に存在するかを逆引きできるようにした上で
シミュレートしたら通った
2番目にある商品のキューから削除して1番目にある商品のキューに追加する処理の
計算量が怪しいなぁー、と思ってたけれども
よくよく考えると全ての操作が高々O(logN)で抑えられるので
それをM回やってO(MlogN)になっても何の問題もなかった
そういえば2列目にある商品が全滅することを考慮していなくて
NPEで1REした

M問題は一見NP問題に見えるけれども
制約をよく見るとKが最大16なので
これを利用するとグラフが一気に小さくなる
具体的にはスタート地点と取引する街の17箇所の互いの距離だけあればよい
この前計算だけ書いてそこから全探索しようとしたけど
よく考えると16!>10^13で間に合わないので
この段階で一度諦めてL問題に戻った

L問題を解き終わってからよくよく考えると
どの順番に回ったかはあまり重要ではなく
「どの街で既に取引をしたか」の状態だけ持てばいいことに気づき
これは2^16=65536で十分小さいので
「どの街で既に取引をしたか」「今どの街にいるか」の2状態でDPをして解いた

N問題とO問題は読んだけど分からなかった
N問題は愚直にシミュレートしか思いつかなかった
遅延評価でなんとかなるものでもなさそうだし
どうすればよかったんだろう・・・